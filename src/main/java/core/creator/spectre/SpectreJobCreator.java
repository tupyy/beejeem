package core.creator.spectre;

import core.creator.Creator;
import core.job.JobState;
import core.job.ModuleController;;
import core.modules.*;
import core.parameters.Parameter;
import core.parameters.ParameterSet;
import core.parameters.parametertypes.*;
import core.util.XMLWorker;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This method creates the parameter set for a spectre job.
 * For each job created a parameter set will be returned.
 * <br>For the job entries which generated an error, a StringParameter will be returned with the description of the error.
 * The name of the StringParameter will be set to the name of the stf file.
 */
public class SpectreJobCreator implements Creator {

    private final Logger logger = LoggerFactory.getLogger(this.getClass().getName());

    private final String spectreParamNames="name,materialName,materialReference,fatigueConfiguration,propaConfiguration";

    /**
     * List of the stf files
     */
    List<File> stfFiles;

    /**
     * file generated by the spectrum generator containing the spectre parameters
     */
    File parameterValuesFile;

    /**
     * Element defining the job
     */
    Element jobDefinitionElement;

    /**
     * Holds the list of the parameter sets created
     */
    List<ParameterSet> parameterSets = new ArrayList<>();

    /**
     * Holds the list of the module created
     */
    List<ModuleController> moduleControllers = new ArrayList<>();

    XMLWorker xmlWorker = new XMLWorker();

    /**
     * @param stfFiles list of the stf files absolute path
     * @param spectreParameterFile absolute path of the file generated by the spectrum generator
     * @param jobDefinitionElement element with the definition of the job
     */
    public SpectreJobCreator(List<File> stfFiles, File spectreParameterFile, Element jobDefinitionElement) {
        this.stfFiles = stfFiles;
        this.parameterValuesFile = spectreParameterFile;
        this.jobDefinitionElement = jobDefinitionElement;
    }

    @Override
    public List<ParameterSet> getParameterSets() {
        return parameterSets;
    }

    @Override
    public List<ModuleController> getModules() {
        return moduleControllers;
    }

    @Override
    public void create() throws IllegalArgumentException, IOException {

        Element parameters = xmlWorker.getElementByName(jobDefinitionElement, "parameters");
        if (parameters == null) {
            logger.error("Parameters element is not found in the job definition element");
            throw new IllegalArgumentException("Parameters element is not found in the job definition element");
        }

        Element code = xmlWorker.getElementByName(jobDefinitionElement, "code");
        if (code == null) {
            logger.error("Code element is not found in the job definition element");
            throw new IllegalArgumentException("Code element is not found in the job definition element");
        }

        Element modules = xmlWorker.getElementByName(jobDefinitionElement, "modules");
        if (modules == null) {
            logger.error("Module element is not found in the job definition element");
            throw new IllegalArgumentException("Module element is not found in the job definition element");
        }

        //create the array of value maps
            ArrayList<HashMap<String,String>> paramValues = getSpectreData(this.parameterValuesFile);

            //create a map with filenames
            HashMap<String,String> filesMap = createFileMap(this.stfFiles);

            for(Map.Entry fileEntry: filesMap.entrySet()) {
                ParameterSet newSet = createParameters(parameters);
                try {
                    newSet.getParameter("filename").setValue(fileEntry.getValue());
                }
                catch (IllegalArgumentException e) {}

                for (HashMap<String, String> paramMap : paramValues) {
                    if (paramMap.get("name").equals(fileEntry.getKey())) {
                        updateParameterSet(newSet, paramMap);
                    }
                }

                newSet.addParameter(createCodeParameter(code));
                parameterSets.add(newSet);
            }


        moduleControllers = createModuleParameter(modules);
    }



    /**
     * Create a parameter set from a list of parameter elements
     * @param parameters {@code ArrayList} of elements defining the parameters
     */
    private ParameterSet createParameters(Element parameters) {

        ParameterSet parameterSet = new ParameterSet();

        ArrayList<Element> parametersList = new ArrayList<>();

        NodeList nodeList = parameters.getChildNodes();
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node node = nodeList.item(i);
            if (node.getNodeType() == Node.ELEMENT_NODE) {
                Element elem = (Element) node;
                if (elem.getNodeName().equals("parameter")) {
                    parametersList.add(elem);
                }
            }
        }
        parameterSet.loadDefinitionFromXML(parametersList);

        return parameterSet;
    }

    /**
     * Create the code parameter
     * @param code element defining the element. The element has been checked.
     */
    private CodeParameter createCodeParameter(Element code) {

        CodeParameter codeParameter = new CodeParameter("pythonCode");
        NodeList nodeList = code.getChildNodes();
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node node = nodeList.item(i);
            if (node.getNodeType() == Node.ELEMENT_NODE) {
                Element elem = (Element) node;
                if (elem.getNodeName().equals("value")) {
                    codeParameter.setValue(elem.getTextContent());
                }
            }
        }

        return codeParameter;
    }

    /**
     * Return a child element with name
     * @param parentElement
     * @param name
     * @return null if don't found
     */
    private Element getElement(Element parentElement,String name) {
        NodeList nodeList = parentElement.getChildNodes();
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node node = nodeList.item(i);
            if (node.getNodeType() == Node.ELEMENT_NODE) {
                Element elem = (Element) node;
                if (elem.getNodeName().equals(name)) {
                    return elem;
                }
            }
        }

        return null;
    }

    /**
     * Create the module parameters
     * @param modulesElement
     */
    private List<ModuleController> createModuleParameter(Element modulesElement) {
        List<ModuleController> moduleSet = new ArrayList<>();

        NodeList nodeList = modulesElement.getChildNodes();
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node node = nodeList.item(i);
            if (node.getNodeType() == Node.ELEMENT_NODE) {
                Element elem = (Element) node;
                if (elem.getNodeName().equals("module")) {
                    try {
                        ModuleController moduleController;
                        if (getElement(elem,"trigger") != null) {
                            moduleController = new ModuleController(getElement(elem,"name").getTextContent(),getStatus(getElement(elem,"trigger").getTextContent()));
                        }
                        else {
                            moduleController = new ModuleController(getElement(elem,"name").getTextContent(),JobState.NONE);
                        }

                        Class<? extends Module> className = (Class<? extends Module>) Class.forName(getElement(elem,"name").getTextContent());
                        Module module = ModuleStarter.getModuleInstance(className);
                        for(String methodName: module.getMethodsName()) {
                            moduleController.addMethod(methodName);
                        }
                        moduleSet.add(moduleController);
                    } catch (ClassNotFoundException e) {

                    }
                }

            }
        }

        return moduleSet;
    }

    /**
     * Map the name of the status to its value in the Jobstate
     * @param triggerName
     * @return
     */
    private int getStatus(String triggerName) {

        return JobState.getStatusCode(triggerName);

    }

    /**
     * Read the dat file and create an entry for each line. For each entry a hashmap is returned with the key as
     * the name of the parameter and the value as the value of the parameter
     * @param datFile
     * @return
     * @throws IOException
     */
    private ArrayList<HashMap<String,String>> getSpectreData(File datFile) throws IOException {
        ArrayList<HashMap<String,String>> output = new ArrayList<>();

        String line;
        String[] spectreParameterNames = spectreParamNames.split(",");

        BufferedReader br = new BufferedReader(new FileReader(datFile));
            while (( line = br.readLine()) != null ) {
                HashMap<String,String> entry = new HashMap<>();
                String[] buffer = line.split("\\s+");

                try {
                    for (int i = 0; i < buffer.length; i++) {
                        entry.put(spectreParameterNames[i], buffer[i]);
                    }
                    output.add(entry);
                }
                 catch (ArrayIndexOutOfBoundsException e) {
                 }
            }
        return output;
    }

    /**
     * Creates a map of filenames having as key the name of file without extention
     * @param stfFiles
     * @return
     */
    private HashMap<String,String> createFileMap(List<File> stfFiles) {
        HashMap<String,String> map = new HashMap<>();

        for (File f: stfFiles) {
            String filename = f.getName();
            String key = filename.substring(0,filename.lastIndexOf("."));
            map.put(key,f.getAbsolutePath());
        }

        return map;
    }

    /**
     * Update the whole set
     * @param parameterSet
     * @param valuesMap
     */
    private void updateParameterSet(ParameterSet parameterSet,HashMap<String,String> valuesMap) {

        for(Parameter p: parameterSet) {
            if (valuesMap.containsKey(p.getName())) {
                String value = valuesMap.get(p.getName());
                    updateParameter(p, value);
            }
        }
    }

    /**
     * Update parameter from String value.
     * The method is casting the value to the ValueType of the parameter.
     * @param p
     * @param value
     */
    private void updateParameter(Parameter p, String value) {
        if (p instanceof BooleanParameter) {
            if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) {
                p.setValue(Boolean.parseBoolean(value));
            }
        }
        else if (p instanceof IntegerParameter) {
            try {
                int valueInt = Integer.parseInt(value);
                p.setValue(valueInt);
            }
            catch (NumberFormatException e) {
                ;
            }
        }
        else if (p instanceof DoubleParameter) {
            try {
                double valueDouble = Double.parseDouble(value);
                p.setValue(valueDouble);
            }
            catch (NumberFormatException e) {
                ;
            }
        }
        else if (p instanceof StringParameter) {
            p.setValue(value);
        }
    }

}
